## Javascript에서의 변수란?

변수(`var`iable)는 **하나의 값을 저장하기 위해 확보한 메모리 공간 그 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름**을 말한다.

Identifier(myNumber) $\rightarrow$ Memory(address: 0012CGSEOP32, value: 23)

```javascript
const myNumber = 23;
// 변수명(식별자): myNumber
// 해당 값의 위치(메모리 주소): 0012CGSEOP32
// 변수 값(저장된 값): 23
```

자바스크립트는 매니지드 언어(managed language)이기 때문에 개발자가 직접 메모리를 제어하지 못한다. 따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 **변수를 통해 안전하게 값에 접근**이 가능하다. <br>
변수명(식별자)인 myNumber는 변수의 값이 아닌 메모리 주소를 기억하고 있다. 변수명을 사용하면, 자바스크립트 엔진이 변수명과 매핑된 메모리 주소를 통해 거기에 저장된 값(23)을 반환한다.

이처럼 변수에 값을 저장하는 것을 <span style="color: #336AF6">**할당**(assignment, 대입, 저장)</span>이라 하며 변수에 저장된 값을 읽어 들이는 것을 <span style="color: #336AF6">**참조**(reference)</span>라 한다. 그리고 변수명을 자바스크립트 엔진에 알리는 것을 <span style="color: #336AF6">**선언**(declaration)</span>이라 한다.
<br>
<br>

## Hoisting이란?

자바스크립트에서 변수의 선언은 `var`, `const`, `let` 으로 할 수 있으며, 변수 선언은 `선언 → 초기화` 단계를 거쳐 수행한다.

-   **선언 단계**: 변수명을 등록하여 자바스크립트 엔진의 변수의 존재를 알린다.
-   **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화한다.

```javascript
var myName;
console.log(myName); // undefined
```

이 때 console을 먼저 찍고 변수를 선언하여도 결과값는 동일하게 나온다. 이는 변수 선언이 런타임에서 되는 것이 아니라, 그 이전 단계에서 먼저 실행되기 때문이다. 자바스크립트 엔진은 소스코드를 한 줄씩 실행하기에 앞서, 변수 선언을 포함한 모든 선언문(ex. 변수 선언문, 함수 선언문)을 찾아내 먼저 실행한다. 즉, <span style="color: #336AF6">변수 선언이 어디에 있든 상관없이 다른 코드보다 먼저 실행하는 특징을 **호이스팅**(Hoising)이라고 한다.</span>

`var`, `const`, `let`, `function`, `class` 키워드를 이용해 선언한 모든 식별자(변수, 함수, 클래스)는 호이스팅이 된다.

변수 선언과 할당은 하나의 문(statement)으로 단축 표현할 수 있지만, 두 개의 실행 시점이 다르다. 변수 선언이 호이스팅되어 런타임 이전에 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 런타임에 실행된다. 따라서 변수의 할당과 console을 실행하는 위치에 따라 반환되는 값이 다르다.

```javascript
console.log(myName); // undefined

var myName = "seop";
console.log(myName); // seop
```

   <br>

## const, let, var 의 차이점

ES6 이전에는 `var`로만 변수를 선언했는데 해당 키워드는 아래와 같은 문제가 있었다.

-   변수 중복 선언 가능하여, 예기치 못한 값을 반환할 수 있다.
-   함수 레벨 스코프로 인해 함수 외부에서 선언한 변수는 모두 전역 변수로 된다.
-   변수 선언문 이전에 변수를 참조하면 언제나 undefined를 반환한다.

ES6에서 `const`와 `let`이 추가됨으로써 문제를 해결했다.

### 변수 중복 선언 불가

1. `let`: 변수 중복 선언이 불가능하지만 **재할당은 가능**하다.
2. `const`: 반드시 **선언과 함께 초기화를 동시에 진행**해야 한다.<br> const도 let과 마찬가지로 재선언이 불가하며, 더 나아가 재할당도 불가하다. 재할당의 경우, 원시 값은 불가능하지만, 객체는 가능하다. **const 키워드는 재할당을 금지할 뿐, ‘불변’을 의미하지 않는다.**

### 블록 레벨 스코프

let, const 키워드로 선언한 변수는 모두 코드 블록(ex. 함수, if, for, while, try/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

### 변수 호이스팅

1. `let`: let 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 선언 단계가 먼저 실행되지만, 초기화 단계가 실행되지 않았을 때 해당 변수에 접근하려고 하면 참조 에러가 뜬다.

```javascript
console.log(name); // output: Uncaught ReferenceError: name is not defined

let name = "seop";
```

따라서 let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없는 <span style="color: #336AF6">**일시적 사각지대(Temporal Dead Zone: TDZ)**</span>구간에 존재한다.

2. `const`: const 키워드는 **선언 단계와 초기화 단계가 동시에 진행**된다.

```javascript
console.log(name); // output: Uncaught ReferenceError: Cannot access 'name' before initialization

let name = "seop";
```

let 키워드로 선언한 경우, 런타임 이전에 선언이 되어 자바스크립트 엔진에 이미 존재하지만 초기화가 되지 않았기 때문에 name is not defined라는 문구가 떴다. 하지만 const 키워드로 선언한 경우, 선언과 초기화가 동시에 이루어져야 하지만 런타임 이전에는 실행될 수 없다. 따라서 초기화가 진행되지 않은 상태이기 때문에 Cannot access 'name' before initialization 에러 문구가 뜬다.
<br>
<br>

## Closure란?

클로저(closure)는 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킨다. 클로저는 자바스크립트를 이용한 고난이도의 테크닉을 구사하는데 필수적인 개념으로 활용된다.<br>
클로저(closure)는 내부함수와 밀접한 관계를 가지고 있는 주제다. 내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 이러한 메커니즘을 클로저라고 한다.

```javascript
function makeAdder(x) {
    var y = 1;
    return function (z) {
        y = 100;
        return x + y + z;
    };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);
//클로저에 x와 y의 환경이 저장됨

console.log(add5(2)); // 107 (x:5 + y:100 + z:2)
console.log(add10(2)); // 112 (x:10 + y:100 + z:2)
//함수 실행 시 클로저에 저장된 x, y값에 접근하여 값을 계산
```

예제에서 단일 인자 x를 받아서 새 함수를 반환하는 함수 makeAdder(x)를 정의했다. 반환되는 함수는 단일인자 z를 받아서 x와 y와 z의 합을 반환한다.

본질적으로 `makeAdder`는 함수를 만들어내는 공장이다. 이는 `makeAdder`함수가 특정한 값을 인자로 가질 수 있는 함수들을 리턴한다는 것을 의미한다. 위의 예제에서 `add5, add10` 두 개의 새로운 함수들을 만들기 위해 `makeAdder`함수 공장을 사용했다. 하나는 매개변수 x에 5를 더하고 다른 하나는 매개변수 x에 10을 더한다.

`add5`와 `add10`은 둘 다 클로저이다. 이들은 같은 함수 본문 정의를 공유하지만 서로 다른 맥락(어휘)적 환경을 저장한다. 함수 실행 시 `add5`의 맥락적 환경에서 클로저 내부의 x는 5 이지만 `add10`의 맥락적 환경에서 x는 10이다. 또한 리턴되는 함수에서 초기값이 1로 할당된 y에 접근하여 y값을 100으로 변경한 것을 볼 수 있다. (물론 x값도 동일하게 변경 가능하다.) 이는 클로저가 리턴된 후에도 외부함수의 변수들에 접근 가능하다는 것을 보여주는 포인트이며 클로저에 단순히 값 형태로 전달되는것이 아니라는 것을 의미한다.

**클로저는 어떤 데이터(어휘적 환경)와 그 데이터를 조작하는 함수를 연관시켜주기 때문에 유용**하다. 이것은 객체가 어떤 데이터와(그 객체의 속성) 하나 혹은 그 이상의 메소드들을 연관시킨다는 점에서 객체지향 프로그래밍과 분명히 같은 맥락에 있다.

결론적으로 <span style="color: #336AF6">**오직 하나의 메소드를 가지고 있는 객체를 일반적으로 사용하는 모든 곳에 클로저를 사용할 수 있다.**</span>
<br>
<br>

## JavaScript Event Loop란?

> 자바스크립트의 큰 특징 중 하나는 '단일 스레드(싱글 스레드)' 기반의 언어라는 점이다.
> 스레드가 하나라는 말은 곧, 동시에 하나의 작업만 처리할 수 있다는 것이다.
> 하지만 실제 자바스크립트 환경에서는 많은 작업이 동시에 처리되고 있다.
> 예를 들어 웹 브라우저에서는 애니메이션 효과를 보여주면서 동시에 입력을 받아 처리한다.
> 어떻게 스레드가 하나인데 이런 일이 가능할까?
> 질문을 바꿔보면 '자바스크립트는 어떻게 동시성(Concurrency)를 지원하는 걸까?'
>
> 출처: 자바스크립트와 이벤트 루프(NHN Cloud | Meetup!)

### 이벤트 루프(Event Loop), 태스크 큐(Task Queue)

자바스크립트 엔진은 `콜 스택(Call stack)`과 `메모리 힙(Memory Heap)`으로 구성되어 있다.

-   콜 스택 <br>
    함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행된다. 자바스크립트는 단 하나의 콜스택을 사용하기 때문에 실행 중인 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까지는 다른 태스크는 실행시키지 않는다.

-   메모리 힙 <br>
    객체가 저장되는 메모리 공간. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.

자바스크립트 엔진은 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행시킨다. 비동기 처리에서 자바스크립트 엔진이 담당한 소스코드 평가, 실행을 제외한 모든 처리는 자바스크립트를 구동하는 환경인 브라우저/Node.js가 한다.

-   자바스크립트 엔진 : setTimeout 콜백 함수 평가/실행 담당
-   브라우저/Node.js : 타이머 설정, 콜백 함수 등록(호출 스케줄링)

#### 실행컨텍스트 동작 순서

1. **전역 코드 평가**<br>
   변수/함수 선언문을 먼저 실행시키고 전역 변수/전역함수를 전역 스코프에 등록 시킴
2. **전역 코드 실행**<br>
   런타임 시작되며 전역 코드가 순차 실행 $\rightarrow$ 전역 변수에 값 할당, 함수 호출을 함 $\rightarrow$ 함수가 호출되면 함수 내부로 들어감
3. **함수 코드 평가**<br>
   함수 내부에 있는 매개변수와 지역 변수 선언문 실행 $\rightarrow$ 매개변수, 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록됨 $\rightarrow$ arugments 객체 생성 및 지역 스코프에 등록, this 바인딩 결정
4. **함수 코드 실행**<br>
   런타임 시작되며 함수 코드 순차 실행 $\rightarrow$ 매개변수, 지역 변수에 값 할당, 내부에 있는 매서드 등 실행
   <br>

### 브라우저 환경 : 태스크 큐, 이벤트 루프

1. 태스크 큐<br>
   setTimeout 이나 setInterval 같은 비동기 함수의 콜백 함수, 이벤트 핸들러가 일시적으로 보관되는 영역이다.

2. 이벤트 루프<br>
   이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기중인 함수(콜백 함수, 이벤트 핸들러..)가 있는지 반복해서 확인한다. 콜스택이 비어 있고 태스크 큐에 대기중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜스택으로 이동시킨다. 이때 콜 스택으로 이동한 함수는 실행된다.

이처럼 이벤트 루프는 스택이 비워지고 나서 태스크 큐에 있는 함수를 순차적으로 콜 스택으로 넣어주기 때문에, 아래와 같은 settimeout 0초 콜백 함수는 console.log Hi와 Seop이 실행된 후 콜 스택이 비워졌을 때 태스크 큐로 이동되어 실행 된다.

이에 따라 아래 코드는 Hi $\rightarrow$ seop $\rightarrow$ Devseop 순으로 콘솔창에 보여지게 된다.

```javascript
console.log("Hi");
setTimeout(function foo() {
    console.log("Seop");
}, 0);
console.log("Devseop");
```
