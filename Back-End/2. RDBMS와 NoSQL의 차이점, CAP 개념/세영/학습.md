# RDBMS와 NoSQL의 차이점, CAP 개념

## RDBMS란

- 현재 DBMS계의 주류. 데이터를 로우(Row: 행, 줄)와 컬럼(Column: 열, 칸)이라는 일종의 표 형태로 저장한다. 데이터의 종속성은 관계(Relation)로 표현한다. relation이란 단어는 테이블을 뜻하기도 한다.
- 한 테이블에 있는 모든 로우는 같은 길이의 컬럼을 가지고 있으며 이 컬럼의 구조와 데이터의 관계가 테이블 스키마(Schema)로 사전 정의된다. 역사가 오래된 만큼 가장 신뢰성이 높고 데이터의 분류, 정렬, 탐색 속도가 빠르다. SQL은 고도로 정교한 검색 쿼리를 제공하며 상상하는 거의 모든 방식으로 데이터를 다룰 수 있게 해 준다. 또한 트랜젝션(Transaction) 지원이 매우 강력하여 신경만 제대로 써주면 데이터가 안 들어가는 경우는 있어도 잘못 들어가는 경우는 없다.
- 예를 들어 금융거래시 구매자 통장에서 돈이 빠져나가고 뒤이어 판매자 통장에 돈이 들어와야 거래가 정상적으로 끝나게 되는데 만약 판매자 통장을 관리하던 컴퓨터가 맛이 갔다고 한다면 RDBMS는 트랜젝션 롤백을 통해 구매자 통장의 잔금을 원상복구 시키면서 거래를 취소한다.
- 여기선 간단하게 설명했지만 현실에서는 네트워크 이상, 데이터 비트 오염, 하드디스크 이상, 동시성 문제 등 데이터 무결성을 보장하기 위해 넘어야 할 산이 많다. 근데 이 모든 상황을 다 고려해서 그 어떤 상황에서도 데이터 무결성을 '보장'하는 게 RDBMS의 특징이다.
- 다른 타입의 DBMS는 이 정도의 데이터 무결성을 보장하지 못한다. 한마디로 없는 돈이 허공에서 솟아날 수도 있고 있던 돈이 증발할 수도 있다. 그러나 스키마를 수정하기가 어렵고, 데이터가 2차원 표형태로만 출력되기 때문에 트리 구조로 조직화되는 '객체'들과 궁합이 잘 안맞는 게 문제다.
- 이 문제는 ORM(Object-Relation Mapping)기법으로 해결하고는 있으나 밑에 설명하는 객체형, 문서형 DB가 더 객체 친화적이므로 신규 프로젝트를 시작하는 경우라면 ORM과 객체형 DB사이에서 잘 저울질해보자.
- DBMS가 부하 분산이 잘 안된다. 대부분의 RDBMS에서 읽기 작업은 분산이 되지만 쓰기 작업까지 분산하려면 고도의 기술력에 더해 전략까지 필요하다.
- 대표적인 RDBMS로는 Oracle, MySQL, Microsoft SQL Server, PostgreSQL 등이 있다.

## NoSQL?

- 단어 뜻 그 자체를 따지자면 "Not only SQL"로, SQL만을 사용하지 않는 데이터베이스 관리 시스템(DBMS)을 지칭하는 단어이다. 관계형 데이터베이스를 사용하지 않는다는 의미가 아닌, 여러 유형의 데이터베이스를 사용한다는 개념이다.
- 데이터를 조직하는 방법에는 리스트, 해시 테이블, 트리, 그래프 등의 다양한 방법이 있고 각각은 장점과 단점이 명확하기 때문에 단순히 NoSQL이라고 만 해서는 설명이 부족하다. NoSQL이라는 단어는 RDBMS가 데이터베이스의 독점적인 지위를 차지하고 있는 현재 상황에 반발하는 정신을 담고 있다.

# **RDBMS와 NoSQL의 장단점**

### **RDBMS**

### **장점**

- 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장하고 있습니다.
- 각 데이터를 중복 없이 한 번만 저장할 수 있습니다.

### **단점**

- 테이블 간에 관계를 맺고 있어 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리가 만들어질 수 있습니다.
- 성능 향상을 위해서는 서버의 성능을 향상 시켜야 하는 Scale-up(성능 업그레이드)만을 지원합니다. 이로 인해 비용이 기하급수적으로 늘어날 수 있습니다.
- 스키마로 인해 데이터가 유연하지 못합니다. 나중에 스키마가 변경 될 경우 번거롭고 어렵습니다.

### **NoSQL**

### **장점**

- NoSQL에서는 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있습니다. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있습니다.
- 데이터 분산이 용이하며 성능 향상을 위한 Saclue-up 뿐만이 아닌 Scale-out(여러 장비로 분산 처리하는 것)또한 가능합니다.

### **단점**

- 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경 될 경우 수정을 모든 컬렉션에서 수행을 해야 합니다.
- 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정이 어려울 수 있습니다.

# **RDBMS, NoSQL 언제 사용해야 될까요?**

- **RDBMS**는 데이터 구조가 명확하며 변경 될 여지가 없으며 명확한 스키마가 중요한 경우 사용하는 것이 좋습니다. 또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다.
- **NoSQL**은 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장이 될 수 있는 경우에 사용하는 것이 좋습니다. 또한 단점에서도 명확하듯이 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시에는 모든 컬렉션에서 수정을 해야 합니다. 이러한 특징들을 기반으로 Update가 많이 이루어지지 않는 시스템이 좋으며 또한 Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 Database를 Scale-Out를 해야 되는 시스템에 적합합니다.

## CAP Theorem

CAP 정리는 **분산 컴퓨터 시스템**에서 다음의 세 가지 조건을 모두 만족하는 것이 불가능하다는 것을 증명한 정리이다. 

- Consistency: 일관성, 일관성을 가진다는 것은 모든 데이터를 요청할 때 응답으로 가장 최신의 변경된 데이터를 리턴 또는 실패를 리턴한다는 것입니다. 즉, 모든 읽기에 대해서 DB노드가 항상 동일한 데이터를 가지고 있어야 한다는 의미입니다.
- Availability: [가용성](https://johngrib.github.io/wiki/availability), 가용성은 모든 요청에 대해서 정상적인 응답을 한다는 것입니다. 즉, 클러스터의 노드 일부에서 장애(Down 등)가 발생하더라도 READ와 WRITE 등의 동작은 항상 성공적으로 리턴되어야 한다는 것입니다.
- Partition Tolerance: 분할 내구성이란 DB Node간의 통신 장애가 발생하더라도 동작해야 한다는 것입니다. Instacne A와 B가 있습니다. 이때 A와 B의 Instance간의 네트워크에 장애가 발생했습니다. 유저는 A DB에서 쿼리를 했습니다. Instance A는 B의 상태를 알지 못하지만 A 만으로 동작합니다. 이를 분할 내구성이라고 합니다.

세 조건을 모두 만족하는 것이 불가능하므로, 만들 수 있는 것은 셋 중 하나를 어느 정도 희생한 시스템이다.

- CP 시스템: [가용성](https://johngrib.github.io/wiki/availability)을 희생한다.
- AP 시스템: 데이터 일관성을 희생한다.
- CA 시스템: 분할 내구성을 희생한다.
- CAP 이론처럼 완벽한 CP, AP 시스템은 없고 대부분 CP와 AP의 어느 중간 쯤에 존재합니다. 그리고 위의 예제에서 봤듯이 configuration에 따라서 변하는 부분이기도 합니다. 또한 이론 자체에 몇 가지 한계점이 존재합니다. 가장 문제가 되는 것이 P에 대한 명확한 정의가 부족하다는 것입니다. 이런 문제점을 극복하고자 **PACELC 이론**이 나오기도 했습니다. 따라서 오늘의 이론은 어디 까지나 **참고**로 봐주시기 바랍니다.

하지만 CAP 중 2가지를 선택할 수 있다는 것은 데이터베이스 선택에 있어서 좋은 기준이 됩니다.